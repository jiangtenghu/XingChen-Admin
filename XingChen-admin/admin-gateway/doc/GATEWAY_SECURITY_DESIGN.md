# ç½‘å…³å®‰å…¨æ¶æ„è®¾è®¡æ–‡æ¡£

## ğŸ¯ è®¾è®¡ç›®æ ‡

æ„å»ºä¸€ä¸ªå®‰å…¨å¯é ã€é«˜æ€§èƒ½çš„APIç½‘å…³å®‰å…¨ä½“ç³»ï¼Œå®ç°ç»Ÿä¸€çš„è®¤è¯é‰´æƒã€æµé‡æ§åˆ¶ã€å®‰å…¨é˜²æŠ¤å’Œå¨èƒæ£€æµ‹åŠŸèƒ½ã€‚

## ğŸ›¡ï¸ å®‰å…¨æ¶æ„æ¦‚è¿°

### å¤šå±‚å®‰å…¨é˜²æŠ¤ä½“ç³»
```
ğŸŒ å¤–éƒ¨ç½‘ç»œ
    â†“
ğŸš§ ç½‘ç»œå±‚å®‰å…¨ (Network Security)
â”œâ”€â”€ DDoSé˜²æŠ¤
â”œâ”€â”€ IPé»‘ç™½åå•
â””â”€â”€ åœ°ç†ä½ç½®è¿‡æ»¤
    â†“
ğŸ”’ ä¼ è¾“å±‚å®‰å…¨ (Transport Security)  
â”œâ”€â”€ HTTPS/TLSåŠ å¯†
â”œâ”€â”€ è¯ä¹¦ç®¡ç†
â””â”€â”€ åè®®å®‰å…¨
    â†“
ğŸ›¡ï¸ åº”ç”¨å±‚å®‰å…¨ (Application Security)
â”œâ”€â”€ èº«ä»½è®¤è¯
â”œâ”€â”€ æƒé™æˆæƒ
â”œâ”€â”€ è¾“å…¥éªŒè¯
â””â”€â”€ è¾“å‡ºç¼–ç 
    â†“
ğŸ“Š ä¸šåŠ¡å±‚å®‰å…¨ (Business Security)
â”œâ”€â”€ ä¸šåŠ¡è§„åˆ™éªŒè¯
â”œâ”€â”€ æ•°æ®æƒé™æ§åˆ¶
â””â”€â”€ å®¡è®¡æ—¥å¿—
```

### å®‰å…¨ç»„ä»¶æ¶æ„
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              å®‰å…¨ç½‘å…³                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚è®¤è¯æ¨¡å— â”‚ â”‚æˆæƒæ¨¡å— â”‚ â”‚å®¡è®¡æ¨¡å— â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚é™æµæ¨¡å— â”‚ â”‚é˜²æŠ¤æ¨¡å— â”‚ â”‚ç›‘æ§æ¨¡å— â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              å®‰å…¨å­˜å‚¨                    â”‚
â”‚  Redisç¼“å­˜ | æ•°æ®åº“ | æ—¥å¿—å­˜å‚¨          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ” èº«ä»½è®¤è¯ç³»ç»Ÿ

### 1. å¤šå› å­è®¤è¯æ¶æ„

#### è®¤è¯æµç¨‹è®¾è®¡
```mermaid
sequenceDiagram
    participant Client as å®¢æˆ·ç«¯
    participant Gateway as ç½‘å…³
    participant Auth as è®¤è¯æœåŠ¡
    participant MFA as å¤šå› å­è®¤è¯
    participant Security as å®‰å…¨ä¸­å¿ƒ
    
    Client->>Gateway: ç™»å½•è¯·æ±‚
    Gateway->>Auth: éªŒè¯ç”¨æˆ·åå¯†ç 
    Auth-->>Gateway: åŸºç¡€è®¤è¯ç»“æœ
    
    alt éœ€è¦å¤šå› å­è®¤è¯
        Gateway->>MFA: å‘èµ·MFAéªŒè¯
        MFA->>Client: å‘é€éªŒè¯ç 
        Client->>MFA: æäº¤éªŒè¯ç 
        MFA-->>Gateway: MFAéªŒè¯ç»“æœ
    end
    
    Gateway->>Security: å®‰å…¨æ£€æŸ¥
    Security-->>Gateway: å®‰å…¨è¯„ä¼°ç»“æœ
    Gateway-->>Client: æœ€ç»ˆè®¤è¯ç»“æœ
```

#### è®¤è¯å®‰å…¨è¿‡æ»¤å™¨
```java
@Component
public class SecurityAuthenticationFilter implements GatewayFilter, Ordered {
    
    @Autowired
    private AuthenticationService authenticationService;
    
    @Autowired
    private SecurityAssessmentService securityAssessmentService;
    
    @Autowired
    private AuditService auditService;
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        
        // 1. æå–è®¤è¯ä¿¡æ¯
        return extractAuthenticationInfo(request)
            .flatMap(authInfo -> {
                // 2. åŸºç¡€è®¤è¯éªŒè¯
                return performBasicAuthentication(authInfo)
                    .flatMap(basicResult -> {
                        if (!basicResult.isSuccess()) {
                            return handleAuthenticationFailure(exchange, basicResult);
                        }
                        
                        // 3. å®‰å…¨é£é™©è¯„ä¼°
                        return assessSecurityRisk(request, authInfo)
                            .flatMap(riskLevel -> {
                                // 4. æ ¹æ®é£é™©ç­‰çº§å†³å®šè®¤è¯ç­–ç•¥
                                return applyAuthenticationStrategy(exchange, authInfo, riskLevel)
                                    .flatMap(finalResult -> {
                                        if (!finalResult.isSuccess()) {
                                            return handleAuthenticationFailure(exchange, finalResult);
                                        }
                                        
                                        // 5. è®°å½•è®¤è¯æˆåŠŸæ—¥å¿—
                                        auditService.logAuthenticationSuccess(authInfo, riskLevel);
                                        
                                        // 6. è®¾ç½®å®‰å…¨ä¸Šä¸‹æ–‡
                                        return setSecurityContext(exchange, finalResult)
                                            .then(chain.filter(exchange));
                                    });
                            });
                    });
            })
            .onErrorResume(ex -> handleAuthenticationError(exchange, ex));
    }
    
    /**
     * å®‰å…¨é£é™©è¯„ä¼°
     */
    private Mono<SecurityRiskLevel> assessSecurityRisk(ServerHttpRequest request, AuthenticationInfo authInfo) {
        return Mono.fromCallable(() -> {
            SecurityContext context = SecurityContext.builder()
                .userId(authInfo.getUserId())
                .clientIp(getClientIp(request))
                .userAgent(getUserAgent(request))
                .timestamp(LocalDateTime.now())
                .build();
                
            return securityAssessmentService.assessRisk(context);
        })
        .subscribeOn(Schedulers.boundedElastic());
    }
    
    /**
     * åº”ç”¨è®¤è¯ç­–ç•¥
     */
    private Mono<AuthenticationResult> applyAuthenticationStrategy(
            ServerWebExchange exchange, 
            AuthenticationInfo authInfo, 
            SecurityRiskLevel riskLevel) {
        
        switch (riskLevel) {
            case LOW:
                return Mono.just(AuthenticationResult.success(authInfo));
                
            case MEDIUM:
                return performEnhancedVerification(authInfo);
                
            case HIGH:
                return performMultiFactorAuthentication(exchange, authInfo);
                
            case CRITICAL:
                return performStrictAuthentication(exchange, authInfo);
                
            default:
                return Mono.just(AuthenticationResult.failure("æœªçŸ¥é£é™©ç­‰çº§"));
        }
    }
    
    /**
     * å¤šå› å­è®¤è¯
     */
    private Mono<AuthenticationResult> performMultiFactorAuthentication(
            ServerWebExchange exchange, 
            AuthenticationInfo authInfo) {
        
        return authenticationService.checkMfaRequired(authInfo.getUserId())
            .flatMap(mfaRequired -> {
                if (!mfaRequired) {
                    return Mono.just(AuthenticationResult.success(authInfo));
                }
                
                // æ£€æŸ¥MFAä»¤ç‰Œ
                String mfaToken = extractMfaToken(exchange.getRequest());
                if (StringUtils.isEmpty(mfaToken)) {
                    return Mono.just(AuthenticationResult.mfaRequired("éœ€è¦å¤šå› å­è®¤è¯"));
                }
                
                return authenticationService.verifyMfaToken(authInfo.getUserId(), mfaToken)
                    .map(verified -> verified ? 
                        AuthenticationResult.success(authInfo) : 
                        AuthenticationResult.failure("å¤šå› å­è®¤è¯å¤±è´¥"));
            });
    }
    
    @Override
    public int getOrder() {
        return -200; // æœ€é«˜ä¼˜å…ˆçº§
    }
}
```

### 2. JWTå®‰å…¨å¢å¼º

#### å®‰å…¨JWTç®¡ç†å™¨
```java
@Service
public class SecureJwtManager {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private SecurityConfig securityConfig;
    
    private final Map<String, SecretKey> keyRotationMap = new ConcurrentHashMap<>();
    
    /**
     * ç”Ÿæˆå®‰å…¨JWTä»¤ç‰Œ
     */
    public String generateSecureToken(UserAuthenticationInfo userInfo) {
        // 1. é€‰æ‹©å½“å‰å¯†é’¥
        SecretKey currentKey = getCurrentSigningKey();
        String keyId = getCurrentKeyId();
        
        // 2. æ„å»ºJWTå£°æ˜
        JwtClaimsSet claims = JwtClaimsSet.builder()
            .issuer("admin-gateway")
            .subject(String.valueOf(userInfo.getUserId()))
            .audience(Collections.singletonList("admin-services"))
            .issuedAt(Instant.now())
            .expiresAt(Instant.now().plus(securityConfig.getTokenExpiration()))
            .claim("username", userInfo.getUsername())
            .claim("tenantId", userInfo.getTenantId())
            .claim("roles", userInfo.getRoles())
            .claim("permissions", userInfo.getPermissions())
            .claim("sessionId", generateSessionId())
            .claim("keyId", keyId) // å¯†é’¥IDç”¨äºå¯†é’¥è½®æ¢
            .build();
        
        // 3. ç­¾åJWT
        JwtEncoder jwtEncoder = createJwtEncoder(currentKey);
        Jwt jwt = jwtEncoder.encode(JwtEncoderParameters.from(claims));
        
        // 4. å­˜å‚¨ä»¤ç‰Œå…ƒæ•°æ®
        storeTokenMetadata(jwt.getTokenValue(), userInfo);
        
        return jwt.getTokenValue();
    }
    
    /**
     * éªŒè¯å®‰å…¨JWTä»¤ç‰Œ
     */
    public TokenValidationResult validateSecureToken(String token) {
        try {
            // 1. è§£æJWTå¤´éƒ¨è·å–å¯†é’¥ID
            String keyId = extractKeyId(token);
            SecretKey signingKey = getSigningKey(keyId);
            
            if (signingKey == null) {
                return TokenValidationResult.invalid("æ— æ•ˆçš„å¯†é’¥ID");
            }
            
            // 2. éªŒè¯JWTç­¾åå’Œæœ‰æ•ˆæœŸ
            JwtDecoder jwtDecoder = createJwtDecoder(signingKey);
            Jwt jwt = jwtDecoder.decode(token);
            
            // 3. æ£€æŸ¥ä»¤ç‰Œæ˜¯å¦åœ¨é»‘åå•ä¸­
            if (isTokenBlacklisted(token)) {
                return TokenValidationResult.invalid("ä»¤ç‰Œå·²è¢«æ’¤é”€");
            }
            
            // 4. éªŒè¯ä¼šè¯æœ‰æ•ˆæ€§
            String sessionId = jwt.getClaimAsString("sessionId");
            if (!isSessionValid(sessionId)) {
                return TokenValidationResult.invalid("ä¼šè¯å·²å¤±æ•ˆ");
            }
            
            // 5. æ£€æŸ¥ä»¤ç‰Œæ˜¯å¦éœ€è¦åˆ·æ–°
            boolean needsRefresh = checkTokenRefreshNeeded(jwt);
            
            // 6. æ„å»ºéªŒè¯ç»“æœ
            return TokenValidationResult.builder()
                .valid(true)
                .userId(Long.parseLong(jwt.getSubject()))
                .username(jwt.getClaimAsString("username"))
                .tenantId(jwt.getClaimAsString("tenantId"))
                .roles(jwt.getClaimAsStringList("roles"))
                .permissions(jwt.getClaimAsStringList("permissions"))
                .sessionId(sessionId)
                .needsRefresh(needsRefresh)
                .build();
                
        } catch (JwtException e) {
            return TokenValidationResult.invalid("ä»¤ç‰ŒéªŒè¯å¤±è´¥: " + e.getMessage());
        }
    }
    
    /**
     * å¯†é’¥è½®æ¢
     */
    @Scheduled(cron = "0 0 2 * * ?") // æ¯å¤©å‡Œæ™¨2ç‚¹æ‰§è¡Œ
    public void rotateSigningKeys() {
        try {
            // 1. ç”Ÿæˆæ–°å¯†é’¥
            SecretKey newKey = generateNewSigningKey();
            String newKeyId = generateKeyId();
            
            // 2. å­˜å‚¨æ–°å¯†é’¥
            keyRotationMap.put(newKeyId, newKey);
            
            // 3. æ›´æ–°å½“å‰å¯†é’¥ID
            updateCurrentKeyId(newKeyId);
            
            // 4. æ¸…ç†è¿‡æœŸå¯†é’¥
            cleanupExpiredKeys();
            
            log.info("å¯†é’¥è½®æ¢å®Œæˆï¼Œæ–°å¯†é’¥ID: {}", newKeyId);
            
        } catch (Exception e) {
            log.error("å¯†é’¥è½®æ¢å¤±è´¥", e);
            alertService.sendAlert("å¯†é’¥è½®æ¢å¤±è´¥", AlertLevel.CRITICAL);
        }
    }
    
    /**
     * ä»¤ç‰Œåˆ·æ–°
     */
    public String refreshToken(String oldToken) {
        TokenValidationResult validation = validateSecureToken(oldToken);
        if (!validation.isValid()) {
            throw new TokenRefreshException("æ— æ³•åˆ·æ–°æ— æ•ˆä»¤ç‰Œ");
        }
        
        // 1. æ’¤é”€æ—§ä»¤ç‰Œ
        revokeToken(oldToken);
        
        // 2. ç”Ÿæˆæ–°ä»¤ç‰Œ
        UserAuthenticationInfo userInfo = UserAuthenticationInfo.builder()
            .userId(validation.getUserId())
            .username(validation.getUsername())
            .tenantId(validation.getTenantId())
            .roles(validation.getRoles())
            .permissions(validation.getPermissions())
            .build();
            
        return generateSecureToken(userInfo);
    }
    
    /**
     * æ’¤é”€ä»¤ç‰Œ
     */
    public void revokeToken(String token) {
        // 1. æ·»åŠ åˆ°é»‘åå•
        String tokenId = extractTokenId(token);
        Duration expiration = getTokenRemainingExpiration(token);
        redisTemplate.opsForValue().set("blacklist:token:" + tokenId, "revoked", expiration);
        
        // 2. æ¸…ç†ä»¤ç‰Œå…ƒæ•°æ®
        clearTokenMetadata(token);
        
        // 3. è®°å½•æ’¤é”€æ—¥å¿—
        auditService.logTokenRevocation(tokenId);
    }
}
```

### 3. ä¼šè¯å®‰å…¨ç®¡ç†

#### å®‰å…¨ä¼šè¯ç®¡ç†å™¨
```java
@Service
public class SecureSessionManager {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private SecurityEventPublisher eventPublisher;
    
    /**
     * åˆ›å»ºå®‰å…¨ä¼šè¯
     */
    public SecureSession createSession(UserAuthenticationInfo userInfo, HttpServletRequest request) {
        String sessionId = generateSecureSessionId();
        
        SecureSession session = SecureSession.builder()
            .sessionId(sessionId)
            .userId(userInfo.getUserId())
            .username(userInfo.getUsername())
            .tenantId(userInfo.getTenantId())
            .clientIp(getClientIp(request))
            .userAgent(getUserAgent(request))
            .createTime(LocalDateTime.now())
            .lastAccessTime(LocalDateTime.now())
            .maxInactiveInterval(Duration.ofMinutes(30))
            .attributes(new ConcurrentHashMap<>())
            .build();
        
        // 1. æ£€æŸ¥å¹¶å‘ä¼šè¯é™åˆ¶
        enforceSessionConcurrencyLimit(userInfo.getUserId());
        
        // 2. å­˜å‚¨ä¼šè¯
        storeSession(session);
        
        // 3. ç»‘å®šç”¨æˆ·ä¼šè¯
        bindUserSession(userInfo.getUserId(), sessionId);
        
        // 4. å‘å¸ƒä¼šè¯åˆ›å»ºäº‹ä»¶
        eventPublisher.publishEvent(new SessionCreatedEvent(session));
        
        return session;
    }
    
    /**
     * éªŒè¯ä¼šè¯
     */
    public SessionValidationResult validateSession(String sessionId, HttpServletRequest request) {
        SecureSession session = getSession(sessionId);
        if (session == null) {
            return SessionValidationResult.invalid("ä¼šè¯ä¸å­˜åœ¨");
        }
        
        // 1. æ£€æŸ¥ä¼šè¯æ˜¯å¦è¿‡æœŸ
        if (isSessionExpired(session)) {
            removeSession(sessionId);
            return SessionValidationResult.invalid("ä¼šè¯å·²è¿‡æœŸ");
        }
        
        // 2. æ£€æŸ¥IPåœ°å€æ˜¯å¦ä¸€è‡´ï¼ˆå¯é€‰ï¼‰
        if (securityConfig.isStrictIpBinding()) {
            String currentIp = getClientIp(request);
            if (!Objects.equals(session.getClientIp(), currentIp)) {
                // IPåœ°å€å˜åŒ–ï¼Œå¯èƒ½å­˜åœ¨ä¼šè¯åŠ«æŒé£é™©
                eventPublisher.publishEvent(new SuspiciousActivityEvent(
                    session.getUserId(), "IPåœ°å€å˜åŒ–", session.getClientIp(), currentIp));
                    
                if (securityConfig.isStrictSecurityMode()) {
                    removeSession(sessionId);
                    return SessionValidationResult.invalid("ä¼šè¯å®‰å…¨éªŒè¯å¤±è´¥");
                }
            }
        }
        
        // 3. æ£€æŸ¥ç”¨æˆ·ä»£ç†æ˜¯å¦ä¸€è‡´ï¼ˆå¯é€‰ï¼‰
        if (securityConfig.isStrictUserAgentBinding()) {
            String currentUserAgent = getUserAgent(request);
            if (!Objects.equals(session.getUserAgent(), currentUserAgent)) {
                eventPublisher.publishEvent(new SuspiciousActivityEvent(
                    session.getUserId(), "ç”¨æˆ·ä»£ç†å˜åŒ–", session.getUserAgent(), currentUserAgent));
            }
        }
        
        // 4. æ›´æ–°æœ€åè®¿é—®æ—¶é—´
        session.setLastAccessTime(LocalDateTime.now());
        updateSession(session);
        
        return SessionValidationResult.valid(session);
    }
    
    /**
     * å¹¶å‘ä¼šè¯é™åˆ¶
     */
    private void enforceSessionConcurrencyLimit(Long userId) {
        int maxConcurrentSessions = securityConfig.getMaxConcurrentSessions();
        if (maxConcurrentSessions <= 0) {
            return; // æ— é™åˆ¶
        }
        
        List<String> userSessions = getUserSessions(userId);
        if (userSessions.size() >= maxConcurrentSessions) {
            // åˆ é™¤æœ€æ—§çš„ä¼šè¯
            String oldestSessionId = findOldestSession(userSessions);
            removeSession(oldestSessionId);
            
            eventPublisher.publishEvent(new SessionEvictedEvent(userId, oldestSessionId, "å¹¶å‘ä¼šè¯é™åˆ¶"));
        }
    }
    
    /**
     * ä¼šè¯æ¸…ç†ä»»åŠ¡
     */
    @Scheduled(fixedRate = 300000) // 5åˆ†é’Ÿæ‰§è¡Œä¸€æ¬¡
    public void cleanupExpiredSessions() {
        try {
            Set<String> allSessionKeys = redisTemplate.keys("session:*");
            if (allSessionKeys == null || allSessionKeys.isEmpty()) {
                return;
            }
            
            List<String> expiredSessions = new ArrayList<>();
            
            for (String sessionKey : allSessionKeys) {
                SecureSession session = (SecureSession) redisTemplate.opsForValue().get(sessionKey);
                if (session != null && isSessionExpired(session)) {
                    expiredSessions.add(session.getSessionId());
                }
            }
            
            // æ‰¹é‡åˆ é™¤è¿‡æœŸä¼šè¯
            if (!expiredSessions.isEmpty()) {
                expiredSessions.forEach(this::removeSession);
                log.info("æ¸…ç†è¿‡æœŸä¼šè¯ {} ä¸ª", expiredSessions.size());
            }
            
        } catch (Exception e) {
            log.error("ä¼šè¯æ¸…ç†ä»»åŠ¡æ‰§è¡Œå¤±è´¥", e);
        }
    }
    
    /**
     * å¼‚å¸¸ä¼šè¯æ£€æµ‹
     */
    @Scheduled(fixedRate = 600000) // 10åˆ†é’Ÿæ‰§è¡Œä¸€æ¬¡
    public void detectAnomalousSessions() {
        try {
            List<SecureSession> allSessions = getAllActiveSessions();
            
            for (SecureSession session : allSessions) {
                // 1. æ£€æµ‹é•¿æ—¶é—´æ´»è·ƒä¼šè¯
                if (isLongRunningSession(session)) {
                    eventPublisher.publishEvent(new AnomalousSessionEvent(
                        session, AnomalousSessionType.LONG_RUNNING));
                }
                
                // 2. æ£€æµ‹å¼‚å¸¸è®¿é—®é¢‘ç‡
                if (hasAbnormalAccessFrequency(session)) {
                    eventPublisher.publishEvent(new AnomalousSessionEvent(
                        session, AnomalousSessionType.ABNORMAL_FREQUENCY));
                }
                
                // 3. æ£€æµ‹åœ°ç†ä½ç½®å¼‚å¸¸
                if (hasGeographicAnomaly(session)) {
                    eventPublisher.publishEvent(new AnomalousSessionEvent(
                        session, AnomalousSessionType.GEOGRAPHIC_ANOMALY));
                }
            }
            
        } catch (Exception e) {
            log.error("å¼‚å¸¸ä¼šè¯æ£€æµ‹å¤±è´¥", e);
        }
    }
}
```

## ğŸš§ å®‰å…¨é˜²æŠ¤ç³»ç»Ÿ

### 1. DDoSé˜²æŠ¤

#### DDoSæ£€æµ‹å’Œé˜²æŠ¤
```java
@Component
public class DDoSProtectionFilter implements GatewayFilter, Ordered {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private DDoSProtectionConfig protectionConfig;
    
    @Autowired
    private SecurityEventPublisher eventPublisher;
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        String clientIp = getClientIp(request);
        
        return checkDDoSProtection(clientIp, request)
            .flatMap(protectionResult -> {
                if (protectionResult.isBlocked()) {
                    return handleDDoSBlock(exchange, protectionResult);
                }
                
                if (protectionResult.needsCaptcha()) {
                    return handleCaptchaChallenge(exchange, protectionResult);
                }
                
                return chain.filter(exchange);
            });
    }
    
    /**
     * DDoSæ£€æµ‹
     */
    private Mono<DDoSProtectionResult> checkDDoSProtection(String clientIp, ServerHttpRequest request) {
        return Mono.fromCallable(() -> {
            // 1. æ£€æŸ¥IPé»‘åå•
            if (isIpBlacklisted(clientIp)) {
                return DDoSProtectionResult.blocked("IPåœ¨é»‘åå•ä¸­");
            }
            
            // 2. æ£€æŸ¥IPç™½åå•
            if (isIpWhitelisted(clientIp)) {
                return DDoSProtectionResult.allowed();
            }
            
            // 3. æ£€æŸ¥è¯·æ±‚é¢‘ç‡
            RequestFrequencyResult frequencyResult = checkRequestFrequency(clientIp);
            if (frequencyResult.exceedsThreshold()) {
                return handleFrequencyExceeded(clientIp, frequencyResult);
            }
            
            // 4. æ£€æŸ¥è¯·æ±‚æ¨¡å¼
            RequestPatternResult patternResult = analyzeRequestPattern(clientIp, request);
            if (patternResult.isSuspicious()) {
                return handleSuspiciousPattern(clientIp, patternResult);
            }
            
            // 5. æ£€æŸ¥åœ°ç†ä½ç½®å¼‚å¸¸
            GeolocationResult geoResult = checkGeolocationAnomaly(clientIp);
            if (geoResult.isAnomalous()) {
                return handleGeolocationAnomaly(clientIp, geoResult);
            }
            
            return DDoSProtectionResult.allowed();
        })
        .subscribeOn(Schedulers.boundedElastic());
    }
    
    /**
     * è¯·æ±‚é¢‘ç‡æ£€æŸ¥
     */
    private RequestFrequencyResult checkRequestFrequency(String clientIp) {
        String key = "ddos:freq:" + clientIp;
        long currentTime = System.currentTimeMillis();
        long windowStart = currentTime - protectionConfig.getFrequencyWindowSize();
        
        // æ¸…ç†è¿‡æœŸæ•°æ®
        redisTemplate.opsForZSet().removeRangeByScore(key, 0, windowStart);
        
        // è·å–å½“å‰çª—å£å†…çš„è¯·æ±‚æ•°é‡
        Long requestCount = redisTemplate.opsForZSet().count(key, windowStart, currentTime);
        
        // è®°å½•å½“å‰è¯·æ±‚
        redisTemplate.opsForZSet().add(key, UUID.randomUUID().toString(), currentTime);
        redisTemplate.expire(key, Duration.ofMillis(protectionConfig.getFrequencyWindowSize()));
        
        RequestFrequencyResult result = new RequestFrequencyResult();
        result.setRequestCount(requestCount != null ? requestCount.intValue() : 0);
        result.setThreshold(protectionConfig.getFrequencyThreshold());
        result.setWindowSize(protectionConfig.getFrequencyWindowSize());
        
        return result;
    }
    
    /**
     * è¯·æ±‚æ¨¡å¼åˆ†æ
     */
    private RequestPatternResult analyzeRequestPattern(String clientIp, ServerHttpRequest request) {
        RequestPatternAnalyzer analyzer = new RequestPatternAnalyzer();
        
        // 1. åˆ†æè¯·æ±‚è·¯å¾„æ¨¡å¼
        String path = request.getPath().toString();
        PatternScore pathScore = analyzer.analyzePathPattern(clientIp, path);
        
        // 2. åˆ†æè¯·æ±‚å¤´æ¨¡å¼
        HttpHeaders headers = request.getHeaders();
        PatternScore headerScore = analyzer.analyzeHeaderPattern(clientIp, headers);
        
        // 3. åˆ†æè¯·æ±‚å‚æ•°æ¨¡å¼
        MultiValueMap<String, String> params = request.getQueryParams();
        PatternScore paramScore = analyzer.analyzeParamPattern(clientIp, params);
        
        // 4. è®¡ç®—ç»¼åˆå¯ç–‘åº¦åˆ†æ•°
        double suspiciousScore = (pathScore.getScore() + headerScore.getScore() + paramScore.getScore()) / 3.0;
        
        RequestPatternResult result = new RequestPatternResult();
        result.setSuspiciousScore(suspiciousScore);
        result.setSuspiciousThreshold(protectionConfig.getPatternSuspiciousThreshold());
        result.setPathScore(pathScore);
        result.setHeaderScore(headerScore);
        result.setParamScore(paramScore);
        
        return result;
    }
    
    /**
     * å¤„ç†é¢‘ç‡è¶…é™
     */
    private DDoSProtectionResult handleFrequencyExceeded(String clientIp, RequestFrequencyResult frequencyResult) {
        int requestCount = frequencyResult.getRequestCount();
        int threshold = frequencyResult.getThreshold();
        
        if (requestCount > threshold * 2) {
            // ä¸¥é‡è¶…é™ï¼Œç›´æ¥å°ç¦
            blockIp(clientIp, Duration.ofHours(1), "è¯·æ±‚é¢‘ç‡ä¸¥é‡è¶…é™");
            eventPublisher.publishEvent(new DDoSAttackEvent(clientIp, DDoSAttackType.FREQUENCY_FLOOD, requestCount));
            return DDoSProtectionResult.blocked("è¯·æ±‚é¢‘ç‡ä¸¥é‡è¶…é™ï¼ŒIPå·²è¢«å°ç¦");
        } else if (requestCount > threshold * 1.5) {
            // ä¸­åº¦è¶…é™ï¼Œè¦æ±‚éªŒè¯ç 
            return DDoSProtectionResult.captchaRequired("è¯·æ±‚é¢‘ç‡è¶…é™ï¼Œéœ€è¦éªŒè¯ç éªŒè¯");
        } else {
            // è½»åº¦è¶…é™ï¼Œè­¦å‘Š
            eventPublisher.publishEvent(new DDoSWarningEvent(clientIp, "è¯·æ±‚é¢‘ç‡æ¥è¿‘é˜ˆå€¼", requestCount, threshold));
            return DDoSProtectionResult.warning("è¯·æ±‚é¢‘ç‡æ¥è¿‘é˜ˆå€¼");
        }
    }
    
    /**
     * IPå°ç¦ç®¡ç†
     */
    public void blockIp(String ip, Duration duration, String reason) {
        String key = "ddos:blocked:" + ip;
        
        IpBlockInfo blockInfo = new IpBlockInfo();
        blockInfo.setIp(ip);
        blockInfo.setReason(reason);
        blockInfo.setBlockTime(LocalDateTime.now());
        blockInfo.setExpireTime(LocalDateTime.now().plus(duration));
        blockInfo.setBlockDuration(duration);
        
        redisTemplate.opsForValue().set(key, blockInfo, duration);
        
        // è®°å½•å°ç¦æ—¥å¿—
        auditService.logIpBlock(blockInfo);
        
        // å‘é€å‘Šè­¦
        alertService.sendAlert("IPå°ç¦", String.format("IP %s å›  %s è¢«å°ç¦ %d åˆ†é’Ÿ", 
            ip, reason, duration.toMinutes()), AlertLevel.WARNING);
    }
    
    @Override
    public int getOrder() {
        return -300; // æœ€é«˜ä¼˜å…ˆçº§
    }
}
```

### 2. SQLæ³¨å…¥é˜²æŠ¤

#### SQLæ³¨å…¥æ£€æµ‹è¿‡æ»¤å™¨
```java
@Component
public class SqlInjectionProtectionFilter implements GatewayFilter, Ordered {
    
    private static final List<Pattern> SQL_INJECTION_PATTERNS = Arrays.asList(
        Pattern.compile("(?i).*\\b(union|select|insert|update|delete|drop|create|alter|exec|execute)\\b.*"),
        Pattern.compile("(?i).*\\b(script|javascript|vbscript|onload|onerror)\\b.*"),
        Pattern.compile("(?i).*['\";].*"),
        Pattern.compile("(?i).*\\b(or|and)\\s+\\d+\\s*=\\s*\\d+.*"),
        Pattern.compile("(?i).*\\b(sleep|benchmark|waitfor)\\s*\\(.*\\).*")
    );
    
    @Autowired
    private SecurityEventPublisher eventPublisher;
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        
        return checkSqlInjection(request)
            .flatMap(detectionResult -> {
                if (detectionResult.isThreat()) {
                    return handleSqlInjectionThreat(exchange, detectionResult);
                }
                return chain.filter(exchange);
            });
    }
    
    /**
     * SQLæ³¨å…¥æ£€æµ‹
     */
    private Mono<SqlInjectionDetectionResult> checkSqlInjection(ServerHttpRequest request) {
        return Mono.fromCallable(() -> {
            SqlInjectionDetectionResult result = new SqlInjectionDetectionResult();
            
            // 1. æ£€æŸ¥æŸ¥è¯¢å‚æ•°
            MultiValueMap<String, String> queryParams = request.getQueryParams();
            for (Map.Entry<String, List<String>> entry : queryParams.entrySet()) {
                for (String value : entry.getValue()) {
                    SqlInjectionMatch match = detectSqlInjection(value);
                    if (match.isMatch()) {
                        result.addThreat(new SqlInjectionThreat(
                            ThreatLocation.QUERY_PARAM, entry.getKey(), value, match));
                    }
                }
            }
            
            // 2. æ£€æŸ¥è¯·æ±‚å¤´
            HttpHeaders headers = request.getHeaders();
            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {
                for (String value : entry.getValue()) {
                    SqlInjectionMatch match = detectSqlInjection(value);
                    if (match.isMatch()) {
                        result.addThreat(new SqlInjectionThreat(
                            ThreatLocation.HEADER, entry.getKey(), value, match));
                    }
                }
            }
            
            // 3. æ£€æŸ¥è¯·æ±‚è·¯å¾„
            String path = request.getPath().toString();
            SqlInjectionMatch pathMatch = detectSqlInjection(path);
            if (pathMatch.isMatch()) {
                result.addThreat(new SqlInjectionThreat(
                    ThreatLocation.PATH, "path", path, pathMatch));
            }
            
            return result;
        })
        .subscribeOn(Schedulers.boundedElastic());
    }
    
    /**
     * SQLæ³¨å…¥æ¨¡å¼åŒ¹é…
     */
    private SqlInjectionMatch detectSqlInjection(String input) {
        if (StringUtils.isEmpty(input)) {
            return SqlInjectionMatch.noMatch();
        }
        
        String decodedInput = urlDecode(input);
        
        for (int i = 0; i < SQL_INJECTION_PATTERNS.size(); i++) {
            Pattern pattern = SQL_INJECTION_PATTERNS.get(i);
            Matcher matcher = pattern.matcher(decodedInput);
            
            if (matcher.matches()) {
                return SqlInjectionMatch.match(i, pattern.pattern(), matcher.group());
            }
        }
        
        return SqlInjectionMatch.noMatch();
    }
    
    /**
     * å¤„ç†SQLæ³¨å…¥å¨èƒ
     */
    private Mono<Void> handleSqlInjectionThreat(ServerWebExchange exchange, SqlInjectionDetectionResult result) {
        ServerHttpRequest request = exchange.getRequest();
        String clientIp = getClientIp(request);
        
        // 1. è®°å½•å®‰å…¨äº‹ä»¶
        SecurityIncident incident = SecurityIncident.builder()
            .type(SecurityIncidentType.SQL_INJECTION_ATTEMPT)
            .clientIp(clientIp)
            .userAgent(getUserAgent(request))
            .requestPath(request.getPath().toString())
            .threats(result.getThreats())
            .timestamp(LocalDateTime.now())
            .build();
            
        eventPublisher.publishEvent(new SecurityIncidentEvent(incident));
        
        // 2. æ ¹æ®å¨èƒçº§åˆ«é‡‡å–è¡ŒåŠ¨
        ThreatLevel maxThreatLevel = result.getMaxThreatLevel();
        switch (maxThreatLevel) {
            case HIGH:
                // é«˜å¨èƒï¼šå°ç¦IP
                blockIp(clientIp, Duration.ofHours(24), "SQLæ³¨å…¥æ”»å‡»");
                break;
            case MEDIUM:
                // ä¸­å¨èƒï¼šä¸´æ—¶é™åˆ¶
                temporarilyRestrictIp(clientIp, Duration.ofMinutes(30));
                break;
            case LOW:
                // ä½å¨èƒï¼šè®°å½•è­¦å‘Š
                log.warn("æ£€æµ‹åˆ°å¯èƒ½çš„SQLæ³¨å…¥å°è¯•: IP={}, Path={}", clientIp, request.getPath());
                break;
        }
        
        // 3. è¿”å›å®‰å…¨é”™è¯¯å“åº”
        return handleSecurityThreat(exchange, "æ£€æµ‹åˆ°æ½œåœ¨çš„å®‰å…¨å¨èƒ");
    }
    
    @Override
    public int getOrder() {
        return -250;
    }
}
```

### 3. XSSé˜²æŠ¤

#### XSSé˜²æŠ¤è¿‡æ»¤å™¨
```java
@Component
public class XssProtectionFilter implements GatewayFilter, Ordered {
    
    private static final List<Pattern> XSS_PATTERNS = Arrays.asList(
        Pattern.compile("(?i)<script[^>]*>.*?</script>"),
        Pattern.compile("(?i)<iframe[^>]*>.*?</iframe>"),
        Pattern.compile("(?i)javascript:"),
        Pattern.compile("(?i)on\\w+\\s*="),
        Pattern.compile("(?i)<img[^>]+src[\\s]*=[\\s]*[\"\\']?[\\s]*javascript:"),
        Pattern.compile("(?i)<[^>]+style[\\s]*=[\\s]*[\"\\']?[^\"\\'>]*expression[\\s]*\\(")
    );
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        
        return checkXssThreats(request)
            .flatMap(detectionResult -> {
                if (detectionResult.hasThreat()) {
                    return handleXssThreat(exchange, detectionResult);
                }
                return chain.filter(exchange);
            });
    }
    
    /**
     * XSSå¨èƒæ£€æµ‹
     */
    private Mono<XssDetectionResult> checkXssThreats(ServerHttpRequest request) {
        return Mono.fromCallable(() -> {
            XssDetectionResult result = new XssDetectionResult();
            
            // 1. æ£€æŸ¥æŸ¥è¯¢å‚æ•°
            MultiValueMap<String, String> queryParams = request.getQueryParams();
            for (Map.Entry<String, List<String>> entry : queryParams.entrySet()) {
                for (String value : entry.getValue()) {
                    XssThreat threat = detectXss(value);
                    if (threat != null) {
                        threat.setLocation(ThreatLocation.QUERY_PARAM);
                        threat.setParameterName(entry.getKey());
                        result.addThreat(threat);
                    }
                }
            }
            
            // 2. æ£€æŸ¥è¯·æ±‚å¤´
            HttpHeaders headers = request.getHeaders();
            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {
                for (String value : entry.getValue()) {
                    XssThreat threat = detectXss(value);
                    if (threat != null) {
                        threat.setLocation(ThreatLocation.HEADER);
                        threat.setParameterName(entry.getKey());
                        result.addThreat(threat);
                    }
                }
            }
            
            return result;
        })
        .subscribeOn(Schedulers.boundedElastic());
    }
    
    /**
     * XSSæ¨¡å¼æ£€æµ‹
     */
    private XssThreat detectXss(String input) {
        if (StringUtils.isEmpty(input)) {
            return null;
        }
        
        String decodedInput = htmlDecode(urlDecode(input));
        
        for (Pattern pattern : XSS_PATTERNS) {
            Matcher matcher = pattern.matcher(decodedInput);
            if (matcher.find()) {
                return new XssThreat(
                    input,
                    decodedInput,
                    pattern.pattern(),
                    matcher.group(),
                    calculateThreatLevel(pattern, matcher.group())
                );
            }
        }
        
        return null;
    }
    
    /**
     * æ¸…ç†XSSå†…å®¹
     */
    public String sanitizeXss(String input) {
        if (StringUtils.isEmpty(input)) {
            return input;
        }
        
        String sanitized = input;
        
        // 1. HTMLå®ä½“ç¼–ç 
        sanitized = htmlEncode(sanitized);
        
        // 2. ç§»é™¤å±é™©æ ‡ç­¾
        for (Pattern pattern : XSS_PATTERNS) {
            sanitized = pattern.matcher(sanitized).replaceAll("");
        }
        
        // 3. è¿‡æ»¤JavaScriptåè®®
        sanitized = sanitized.replaceAll("(?i)javascript:", "");
        
        // 4. è¿‡æ»¤äº‹ä»¶å¤„ç†å™¨
        sanitized = sanitized.replaceAll("(?i)on\\w+\\s*=\\s*[\"'][^\"']*[\"']", "");
        
        return sanitized;
    }
    
    @Override
    public int getOrder() {
        return -240;
    }
}
```

## ğŸ“Š å®‰å…¨ç›‘æ§ä¸å®¡è®¡

### 1. å®‰å…¨äº‹ä»¶ç›‘æ§

#### å®‰å…¨äº‹ä»¶å¤„ç†å™¨
```java
@Component
public class SecurityEventHandler {
    
    @Autowired
    private SecurityEventRepository eventRepository;
    
    @Autowired
    private AlertService alertService;
    
    @Autowired
    private ThreatIntelligenceService threatIntelligenceService;
    
    /**
     * å¤„ç†å®‰å…¨äº‹ä»¶
     */
    @EventListener
    @Async
    public void handleSecurityEvent(SecurityEvent event) {
        try {
            // 1. æŒä¹…åŒ–äº‹ä»¶
            persistSecurityEvent(event);
            
            // 2. å¨èƒæƒ…æŠ¥åˆ†æ
            ThreatAnalysisResult analysis = threatIntelligenceService.analyzeEvent(event);
            
            // 3. æ ¹æ®å¨èƒçº§åˆ«å¤„ç†
            handleThreatLevel(event, analysis);
            
            // 4. æ›´æ–°å®‰å…¨æŒ‡æ ‡
            updateSecurityMetrics(event);
            
            // 5. è§¦å‘è‡ªåŠ¨å“åº”
            triggerAutomaticResponse(event, analysis);
            
        } catch (Exception e) {
            log.error("å¤„ç†å®‰å…¨äº‹ä»¶å¤±è´¥", e);
        }
    }
    
    /**
     * å¨èƒçº§åˆ«å¤„ç†
     */
    private void handleThreatLevel(SecurityEvent event, ThreatAnalysisResult analysis) {
        switch (analysis.getThreatLevel()) {
            case CRITICAL:
                handleCriticalThreat(event, analysis);
                break;
            case HIGH:
                handleHighThreat(event, analysis);
                break;
            case MEDIUM:
                handleMediumThreat(event, analysis);
                break;
            case LOW:
                handleLowThreat(event, analysis);
                break;
        }
    }
    
    /**
     * å¤„ç†ä¸¥é‡å¨èƒ
     */
    private void handleCriticalThreat(SecurityEvent event, ThreatAnalysisResult analysis) {
        // 1. ç«‹å³å°ç¦æ”»å‡»æº
        if (event.getClientIp() != null) {
            securityService.blockIpImmediately(event.getClientIp(), Duration.ofHours(24));
        }
        
        // 2. å‘é€ç´§æ€¥å‘Šè­¦
        AlertMessage alert = AlertMessage.builder()
            .title("ä¸¥é‡å®‰å…¨å¨èƒæ£€æµ‹")
            .content(String.format("æ£€æµ‹åˆ°ä¸¥é‡å®‰å…¨å¨èƒ: %sï¼Œæ¥æºIP: %s", 
                event.getEventType(), event.getClientIp()))
            .level(AlertLevel.CRITICAL)
            .timestamp(LocalDateTime.now())
            .build();
        alertService.sendUrgentAlert(alert);
        
        // 3. å¯åŠ¨åº”æ€¥å“åº”
        incidentResponseService.initiateEmergencyResponse(event, analysis);
        
        // 4. é€šçŸ¥å®‰å…¨å›¢é˜Ÿ
        securityTeamNotificationService.notifySecurityTeam(event, analysis);
    }
    
    /**
     * å®‰å…¨è¶‹åŠ¿åˆ†æ
     */
    @Scheduled(fixedRate = 300000) // 5åˆ†é’Ÿæ‰§è¡Œä¸€æ¬¡
    public void analyzeSecurityTrends() {
        try {
            LocalDateTime endTime = LocalDateTime.now();
            LocalDateTime startTime = endTime.minusMinutes(5);
            
            // 1. è·å–æ—¶é—´çª—å£å†…çš„å®‰å…¨äº‹ä»¶
            List<SecurityEvent> recentEvents = eventRepository.findByTimestampBetween(startTime, endTime);
            
            // 2. åˆ†æäº‹ä»¶è¶‹åŠ¿
            SecurityTrendAnalysis trendAnalysis = analyzeTrends(recentEvents);
            
            // 3. æ£€æµ‹å¼‚å¸¸æ¨¡å¼
            List<SecurityAnomaly> anomalies = detectAnomalies(trendAnalysis);
            
            // 4. å¤„ç†æ£€æµ‹åˆ°çš„å¼‚å¸¸
            for (SecurityAnomaly anomaly : anomalies) {
                handleSecurityAnomaly(anomaly);
            }
            
            // 5. æ›´æ–°å¨èƒæƒ…æŠ¥
            threatIntelligenceService.updateThreatIntelligence(trendAnalysis);
            
        } catch (Exception e) {
            log.error("å®‰å…¨è¶‹åŠ¿åˆ†æå¤±è´¥", e);
        }
    }
    
    /**
     * ç”Ÿæˆå®‰å…¨æŠ¥å‘Š
     */
    @Scheduled(cron = "0 0 1 * * ?") // æ¯å¤©å‡Œæ™¨1ç‚¹æ‰§è¡Œ
    public void generateDailySecurityReport() {
        try {
            LocalDate reportDate = LocalDate.now().minusDays(1);
            SecurityReport report = generateSecurityReport(reportDate);
            
            // 1. ä¿å­˜æŠ¥å‘Š
            securityReportService.saveReport(report);
            
            // 2. å‘é€æŠ¥å‘Šç»™å®‰å…¨å›¢é˜Ÿ
            securityTeamNotificationService.sendDailyReport(report);
            
            // 3. å¦‚æœæœ‰é«˜é£é™©äº‹ä»¶ï¼Œå‘é€ç‰¹åˆ«é€šçŸ¥
            if (report.hasHighRiskEvents()) {
                alertService.sendAlert("æ¯æ—¥å®‰å…¨æŠ¥å‘Š - å‘ç°é«˜é£é™©äº‹ä»¶", 
                    report.getHighRiskEventsSummary(), AlertLevel.WARNING);
            }
            
        } catch (Exception e) {
            log.error("ç”Ÿæˆæ¯æ—¥å®‰å…¨æŠ¥å‘Šå¤±è´¥", e);
        }
    }
}
```

### 2. å®¡è®¡æ—¥å¿—ç³»ç»Ÿ

#### å®‰å…¨å®¡è®¡æœåŠ¡
```java
@Service
public class SecurityAuditService {
    
    @Autowired
    private AuditLogRepository auditLogRepository;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    /**
     * è®°å½•è®¤è¯å®¡è®¡
     */
    public void logAuthentication(AuthenticationEvent event) {
        AuditLog auditLog = AuditLog.builder()
            .eventType(AuditEventType.AUTHENTICATION)
            .userId(event.getUserId())
            .username(event.getUsername())
            .clientIp(event.getClientIp())
            .userAgent(event.getUserAgent())
            .result(event.getResult())
            .details(buildAuthenticationDetails(event))
            .timestamp(LocalDateTime.now())
            .build();
            
        saveAuditLog(auditLog);
    }
    
    /**
     * è®°å½•æˆæƒå®¡è®¡
     */
    public void logAuthorization(AuthorizationEvent event) {
        AuditLog auditLog = AuditLog.builder()
            .eventType(AuditEventType.AUTHORIZATION)
            .userId(event.getUserId())
            .resource(event.getResource())
            .action(event.getAction())
            .result(event.getResult())
            .details(buildAuthorizationDetails(event))
            .timestamp(LocalDateTime.now())
            .build();
            
        saveAuditLog(auditLog);
    }
    
    /**
     * è®°å½•å®‰å…¨äº‹ä»¶å®¡è®¡
     */
    public void logSecurityIncident(SecurityIncident incident) {
        AuditLog auditLog = AuditLog.builder()
            .eventType(AuditEventType.SECURITY_INCIDENT)
            .clientIp(incident.getClientIp())
            .incidentType(incident.getType().name())
            .threatLevel(incident.getThreatLevel().name())
            .details(buildIncidentDetails(incident))
            .timestamp(LocalDateTime.now())
            .build();
            
        saveAuditLog(auditLog);
    }
    
    /**
     * ä¿å­˜å®¡è®¡æ—¥å¿—
     */
    private void saveAuditLog(AuditLog auditLog) {
        try {
            // 1. å¼‚æ­¥ä¿å­˜åˆ°æ•°æ®åº“
            CompletableFuture.runAsync(() -> {
                auditLogRepository.save(auditLog);
            });
            
            // 2. å®æ—¶å­˜å‚¨åˆ°Redisï¼ˆç”¨äºå¿«é€ŸæŸ¥è¯¢ï¼‰
            String key = "audit:realtime:" + LocalDate.now().toString();
            redisTemplate.opsForList().rightPush(key, auditLog);
            redisTemplate.expire(key, Duration.ofDays(7)); // ä¿ç•™7å¤©
            
            // 3. å¦‚æœæ˜¯é«˜é£é™©äº‹ä»¶ï¼Œç«‹å³å¤„ç†
            if (isHighRiskEvent(auditLog)) {
                handleHighRiskAuditEvent(auditLog);
            }
            
        } catch (Exception e) {
            log.error("ä¿å­˜å®¡è®¡æ—¥å¿—å¤±è´¥", e);
        }
    }
    
    /**
     * å®¡è®¡æ—¥å¿—åˆ†æ
     */
    public AuditAnalysisResult analyzeAuditLogs(AuditAnalysisRequest request) {
        AuditAnalysisResult result = new AuditAnalysisResult();
        
        // 1. è·å–å®¡è®¡æ—¥å¿—
        List<AuditLog> auditLogs = auditLogRepository.findByTimestampBetween(
            request.getStartTime(), request.getEndTime());
        
        // 2. ç»Ÿè®¡åˆ†æ
        result.setTotalEvents(auditLogs.size());
        result.setEventTypeDistribution(calculateEventTypeDistribution(auditLogs));
        result.setUserActivitySummary(calculateUserActivitySummary(auditLogs));
        result.setSecurityIncidentSummary(calculateSecurityIncidentSummary(auditLogs));
        result.setTopRiskyIps(findTopRiskyIps(auditLogs));
        result.setAnomalousActivities(detectAnomalousActivities(auditLogs));
        
        // 3. è¶‹åŠ¿åˆ†æ
        result.setTrendAnalysis(analyzeTrends(auditLogs, request.getTimeGranularity()));
        
        return result;
    }
    
    /**
     * å®¡è®¡æ—¥å¿—å½’æ¡£
     */
    @Scheduled(cron = "0 0 2 * * ?") // æ¯å¤©å‡Œæ™¨2ç‚¹æ‰§è¡Œ
    public void archiveAuditLogs() {
        try {
            LocalDateTime archiveThreshold = LocalDateTime.now().minusDays(90); // 90å¤©å‰çš„æ•°æ®
            
            // 1. æŸ¥æ‰¾éœ€è¦å½’æ¡£çš„æ—¥å¿—
            List<AuditLog> logsToArchive = auditLogRepository.findByTimestampBefore(archiveThreshold);
            
            if (logsToArchive.isEmpty()) {
                return;
            }
            
            // 2. å¯¼å‡ºåˆ°å½’æ¡£æ–‡ä»¶
            String archiveFileName = "audit_archive_" + LocalDate.now().toString() + ".json";
            exportAuditLogsToFile(logsToArchive, archiveFileName);
            
            // 3. ä¸Šä¼ åˆ°äº‘å­˜å‚¨
            cloudStorageService.uploadFile(archiveFileName, getArchiveFilePath(archiveFileName));
            
            // 4. åˆ é™¤å·²å½’æ¡£çš„æ—¥å¿—
            auditLogRepository.deleteAll(logsToArchive);
            
            log.info("å®¡è®¡æ—¥å¿—å½’æ¡£å®Œæˆï¼Œå½’æ¡£æ•°é‡: {}", logsToArchive.size());
            
        } catch (Exception e) {
            log.error("å®¡è®¡æ—¥å¿—å½’æ¡£å¤±è´¥", e);
        }
    }
}
```

## ğŸ”§ å®‰å…¨é…ç½®ç®¡ç†

### å®‰å…¨é…ç½®ç±»
```java
@Configuration
@ConfigurationProperties(prefix = "gateway.security")
@Data
public class SecurityConfig {
    
    /**
     * JWTé…ç½®
     */
    private JwtConfig jwt = new JwtConfig();
    
    /**
     * ä¼šè¯é…ç½®
     */
    private SessionConfig session = new SessionConfig();
    
    /**
     * DDoSé˜²æŠ¤é…ç½®
     */
    private DDoSConfig ddos = new DDoSConfig();
    
    /**
     * å®¡è®¡é…ç½®
     */
    private AuditConfig audit = new AuditConfig();
    
    @Data
    public static class JwtConfig {
        private Duration tokenExpiration = Duration.ofHours(2);
        private Duration refreshExpiration = Duration.ofDays(7);
        private String secretKey = "default-secret-key";
        private boolean enableKeyRotation = true;
        private Duration keyRotationInterval = Duration.ofDays(30);
    }
    
    @Data
    public static class SessionConfig {
        private Duration maxInactiveInterval = Duration.ofMinutes(30);
        private int maxConcurrentSessions = 5;
        private boolean strictIpBinding = false;
        private boolean strictUserAgentBinding = false;
        private boolean strictSecurityMode = false;
    }
    
    @Data
    public static class DDoSConfig {
        private boolean enabled = true;
        private int frequencyThreshold = 100;
        private long frequencyWindowSize = 60000; // 1åˆ†é’Ÿ
        private double patternSuspiciousThreshold = 0.7;
        private List<String> ipWhitelist = new ArrayList<>();
        private List<String> ipBlacklist = new ArrayList<>();
    }
    
    @Data
    public static class AuditConfig {
        private boolean enabled = true;
        private boolean logAuthentication = true;
        private boolean logAuthorization = true;
        private boolean logSecurityIncidents = true;
        private Duration retentionPeriod = Duration.ofDays(90);
        private boolean enableRealTimeAnalysis = true;
    }
}
```

è¿™ä¸ªç½‘å…³å®‰å…¨æ¶æ„è®¾è®¡æä¾›äº†ï¼š

1. **å¤šå±‚å®‰å…¨é˜²æŠ¤** - ç½‘ç»œã€ä¼ è¾“ã€åº”ç”¨ã€ä¸šåŠ¡å››å±‚å®‰å…¨
2. **å®Œå–„çš„è®¤è¯é‰´æƒ** - å¤šå› å­è®¤è¯ã€JWTå®‰å…¨ç®¡ç†ã€ä¼šè¯å®‰å…¨
3. **å…¨é¢çš„æ”»å‡»é˜²æŠ¤** - DDoSã€SQLæ³¨å…¥ã€XSSç­‰æ”»å‡»é˜²æŠ¤
4. **æ™ºèƒ½å¨èƒæ£€æµ‹** - å¼‚å¸¸æ¨¡å¼è¯†åˆ«ã€å¨èƒæƒ…æŠ¥åˆ†æ
5. **å®Œæ•´çš„å®¡è®¡ä½“ç³»** - å®‰å…¨äº‹ä»¶è®°å½•ã€å®¡è®¡æ—¥å¿—ç®¡ç†ã€åˆè§„æŠ¥å‘Š

ç³»ç»Ÿå…·æœ‰é«˜åº¦çš„å®‰å…¨æ€§å’Œå¯æ‰©å±•æ€§ï¼Œèƒ½å¤Ÿæœ‰æ•ˆé˜²æŠ¤å„ç§ç½‘ç»œå®‰å…¨å¨èƒã€‚
